{"ast":null,"code":"class VoiceService {\n  constructor() {\n    this.recognition = null;\n    this.synthesis = window.speechSynthesis;\n    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {\n      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n      this.recognition = new SpeechRecognition();\n      this.recognition.continuous = false;\n      this.recognition.interimResults = false;\n      this.recognition.lang = 'en-US';\n    }\n  }\n  async startListening() {\n    return new Promise((resolve, reject) => {\n      if (!this.recognition) {\n        reject(new Error('Speech recognition not supported'));\n        return;\n      }\n      this.recognition.onresult = event => {\n        const transcript = event.results[0][0].transcript;\n        resolve(transcript);\n      };\n      this.recognition.onerror = event => {\n        reject(new Error(`Speech recognition error: ${event.error}`));\n      };\n      this.recognition.onend = () => {\n        // Recognition ended\n      };\n      try {\n        this.recognition.start();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  stopListening() {\n    if (this.recognition) {\n      this.recognition.stop();\n    }\n  }\n  speak(text, voice) {\n    if (!this.synthesis) {\n      console.warn('Speech synthesis not supported');\n      return;\n    }\n\n    // Cancel any ongoing speech\n    this.synthesis.cancel();\n    const utterance = new SpeechSynthesisUtterance(text);\n    if (voice) {\n      utterance.voice = voice;\n    } else {\n      // Try to use a female voice by default\n      const voices = this.synthesis.getVoices();\n      const femaleVoice = voices.find(voice => voice.name.toLowerCase().includes('female') || voice.name.toLowerCase().includes('samantha') || voice.name.toLowerCase().includes('serena'));\n      if (femaleVoice) {\n        utterance.voice = femaleVoice;\n      }\n    }\n    utterance.rate = 0.9; // Slightly slower for better comprehension\n    utterance.pitch = 1.0;\n    utterance.volume = 0.8;\n    this.synthesis.speak(utterance);\n  }\n  getVoices() {\n    return this.synthesis ? this.synthesis.getVoices() : [];\n  }\n  isSupported() {\n    return !!(this.recognition && this.synthesis);\n  }\n\n  // Convert audio blob to base64 for sending to backend\n  async audioToBase64(audioBlob) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = () => {\n        const base64 = reader.result.split(',')[1];\n        resolve(base64);\n      };\n      reader.onerror = reject;\n      reader.readAsDataURL(audioBlob);\n    });\n  }\n\n  // Record audio for sending to backend speech-to-text service\n  async recordAudio(duration = 5000) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: true\n        });\n        const mediaRecorder = new MediaRecorder(stream);\n        const audioChunks = [];\n        mediaRecorder.addEventListener('dataavailable', event => {\n          audioChunks.push(event.data);\n        });\n        mediaRecorder.addEventListener('stop', async () => {\n          const audioBlob = new Blob(audioChunks, {\n            type: 'audio/wav'\n          });\n          const base64 = await this.audioToBase64(audioBlob);\n\n          // Stop all tracks\n          stream.getTracks().forEach(track => track.stop());\n          resolve(base64);\n        });\n        mediaRecorder.start();\n\n        // Auto-stop after duration\n        setTimeout(() => {\n          if (mediaRecorder.state === 'recording') {\n            mediaRecorder.stop();\n          }\n        }, duration);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n}\nexport default new VoiceService();","map":{"version":3,"names":["VoiceService","constructor","recognition","synthesis","window","speechSynthesis","SpeechRecognition","webkitSpeechRecognition","continuous","interimResults","lang","startListening","Promise","resolve","reject","Error","onresult","event","transcript","results","onerror","error","onend","start","stopListening","stop","speak","text","voice","console","warn","cancel","utterance","SpeechSynthesisUtterance","voices","getVoices","femaleVoice","find","name","toLowerCase","includes","rate","pitch","volume","isSupported","audioToBase64","audioBlob","reader","FileReader","onload","base64","result","split","readAsDataURL","recordAudio","duration","stream","navigator","mediaDevices","getUserMedia","audio","mediaRecorder","MediaRecorder","audioChunks","addEventListener","push","data","Blob","type","getTracks","forEach","track","setTimeout","state"],"sources":["C:/Users/Lenovo/Downloads/New folder (3)/frontend/src/services/VoiceService.ts"],"sourcesContent":["class VoiceService {\r\n  private recognition: any = null;\r\n  private synthesis: SpeechSynthesis = window.speechSynthesis;\r\n  \r\n  constructor() {\r\n    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {\r\n      const SpeechRecognition = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;\r\n      this.recognition = new SpeechRecognition();\r\n      \r\n      this.recognition.continuous = false;\r\n      this.recognition.interimResults = false;\r\n      this.recognition.lang = 'en-US';\r\n    }\r\n  }\r\n  \r\n  async startListening(): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.recognition) {\r\n        reject(new Error('Speech recognition not supported'));\r\n        return;\r\n      }\r\n      \r\n      this.recognition.onresult = (event: any) => {\r\n        const transcript = event.results[0][0].transcript;\r\n        resolve(transcript);\r\n      };\r\n      \r\n      this.recognition.onerror = (event: any) => {\r\n        reject(new Error(`Speech recognition error: ${event.error}`));\r\n      };\r\n      \r\n      this.recognition.onend = () => {\r\n        // Recognition ended\r\n      };\r\n      \r\n      try {\r\n        this.recognition.start();\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n  \r\n  stopListening(): void {\r\n    if (this.recognition) {\r\n      this.recognition.stop();\r\n    }\r\n  }\r\n  \r\n  speak(text: string, voice?: SpeechSynthesisVoice): void {\r\n    if (!this.synthesis) {\r\n      console.warn('Speech synthesis not supported');\r\n      return;\r\n    }\r\n    \r\n    // Cancel any ongoing speech\r\n    this.synthesis.cancel();\r\n    \r\n    const utterance = new SpeechSynthesisUtterance(text);\r\n    \r\n    if (voice) {\r\n      utterance.voice = voice;\r\n    } else {\r\n      // Try to use a female voice by default\r\n      const voices = this.synthesis.getVoices();\r\n      const femaleVoice = voices.find(voice => \r\n        voice.name.toLowerCase().includes('female') || \r\n        voice.name.toLowerCase().includes('samantha') ||\r\n        voice.name.toLowerCase().includes('serena')\r\n      );\r\n      if (femaleVoice) {\r\n        utterance.voice = femaleVoice;\r\n      }\r\n    }\r\n    \r\n    utterance.rate = 0.9; // Slightly slower for better comprehension\r\n    utterance.pitch = 1.0;\r\n    utterance.volume = 0.8;\r\n    \r\n    this.synthesis.speak(utterance);\r\n  }\r\n  \r\n  getVoices(): SpeechSynthesisVoice[] {\r\n    return this.synthesis ? this.synthesis.getVoices() : [];\r\n  }\r\n  \r\n  isSupported(): boolean {\r\n    return !!(this.recognition && this.synthesis);\r\n  }\r\n  \r\n  // Convert audio blob to base64 for sending to backend\r\n  async audioToBase64(audioBlob: Blob): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      reader.onload = () => {\r\n        const base64 = (reader.result as string).split(',')[1];\r\n        resolve(base64);\r\n      };\r\n      reader.onerror = reject;\r\n      reader.readAsDataURL(audioBlob);\r\n    });\r\n  }\r\n  \r\n  // Record audio for sending to backend speech-to-text service\r\n  async recordAudio(duration: number = 5000): Promise<string> {\r\n    return new Promise(async (resolve, reject) => {\r\n      try {\r\n        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n        const mediaRecorder = new MediaRecorder(stream);\r\n        const audioChunks: Blob[] = [];\r\n        \r\n        mediaRecorder.addEventListener('dataavailable', (event) => {\r\n          audioChunks.push(event.data);\r\n        });\r\n        \r\n        mediaRecorder.addEventListener('stop', async () => {\r\n          const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });\r\n          const base64 = await this.audioToBase64(audioBlob);\r\n          \r\n          // Stop all tracks\r\n          stream.getTracks().forEach(track => track.stop());\r\n          \r\n          resolve(base64);\r\n        });\r\n        \r\n        mediaRecorder.start();\r\n        \r\n        // Auto-stop after duration\r\n        setTimeout(() => {\r\n          if (mediaRecorder.state === 'recording') {\r\n            mediaRecorder.stop();\r\n          }\r\n        }, duration);\r\n        \r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default new VoiceService();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}